// Секундомер с индикацией на экране осциллографа.
// Для С1-94 развертка установлена 0.1 ms Время/дел.
// Включена внешняя синхронизация, ждущий режим
// Входной делитель 0.2 V/дел.

char indicator[7] = {0, 0, 10, 0, 0, 10, 0}; // Коды отображаемых символов
// Матрицы символов. Каждый символ состоит из 8 строк и 4-х столбцов.
// Каждый байт массива задает строку для двух символов.
// Например, старший полубайт symbols[1][3] - это четвертая строка для цифры "2".
// В процессе рисования символы отделяются друг от друга пустым "пикселем"
// Итого, с его учетом, ширина символа на экране - 5 "пикселей".
int symbols[6][8] = {
   {B01100001,
    B10010011,
    B10010101,
    B10011001,
    B10010001,
    B10010001,
    B10010001,
    B01100001},
   
   {B01100110,
    B10011001,
    B00010001,
    B00010010,
    B00100010,
    B01000001,
    B10001001,
    B11110110},

   {B10010111,
    B10011000,
    B10011000,
    B11110110,
    B00010001,
    B00010001,
    B00011001,
    B00010110},

   {B01111110,
    B10000001,
    B10000001,
    B01100001,
    B10010010,
    B10010100,
    B10011000,
    B01101000},

   {B01100110,
    B10011001,
    B10011001,
    B01100110,
    B10010001,
    B10010001,
    B10011001,
    B01100110},

   {B00000000,
    B01100000,
    B01100000,
    B00000000,
    B00000000,
    B01100000,
    B01100000,
    B00000000},
         
   };

void setup() {
// Пины 10 и 11 - на вход  
  pinMode(10, INPUT);
  pinMode(11, INPUT);
// Пины 0, 1, 2, 3, 4 - на выход
  DDRD = DDRD | B00011111;
// Устанавливаем параметры таймера
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
// Таймер срабатывает 16 000 000 / 500 = 32 000 раз в секунду
  OCR1A = 500 - 1;
// Режим CTC
  TCCR1B |= (1 << WGM12);
// Предделитель выключен
  TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10); 
// Разрешаем прерывания таймера
  TIMSK1 |= (1 << OCIE1A);  
}

void clearIndicator()
{
  indicator[0] = indicator[1] = indicator[3] = indicator[4] = indicator[6] = 0;  
}

int secCnt = 0; // Счетчик для подсчета секунд
bool isRuning = false; // Флаг "секундомер запущен"
int lev = 0; // Номер текущей строки растра
int col = 0; // Номер текущего "пикселя" в строке
const int MAXCOL = 80; // Максимальный номер "пикселя". После него происходит переход на новую строку
                       // Для достижения устойчивой синхронизации может потребоваться варьировать значение этой константы,
                       // но оно не должно быть меньше 35, иначе не успеют нарисоваться все символы раньше,
                       // чем перейдем на новую строку

ISR(TIMER1_COMPA_vect) {
  if (isRuning) // Если идет счет секунд, обновляем текущие значения
  {
    secCnt++;      
    if (secCnt >= 3200) // Каждые 3200 прерывания таймера увеличиваем показания секундомера на 0.1 секунды
    {
      secCnt = 0;
      indicator[6]++;
      if (indicator[6] > 9)
      {
        indicator[6] = 0;
        indicator[4]++;
        if (indicator[4] > 9)
        {
          indicator[4] = 0;
          indicator[3]++;
          if (indicator[3] > 5)
          {
            indicator[3] = 0;
            indicator[1]++;
            if (indicator[1] > 9)
            {
              indicator[1] = 0;
              indicator[0]++;
              if (indicator[0] > 9)
                clearIndicator();              
            }
          }
        }
      }      
    }
  }
  col = (col < MAXCOL)?col + 1:0;
  if (col == MAXCOL)     // Дошли до последнего "пикселя в строке" - даем синхроимпульс и переходим на следующую строку
  {
    PORTD = (PORTD & B11100000) | B00010000;
    PORTD = (PORTD & B11010000);
    lev = (lev < 7)?lev + 1:0;
    return;
  }
  int col5d = col / 5; // Номер текущего символа
  int col5m = col % 5; // Номер "пекселя" в текущем символе
  if (col5m == 4)
    PORTD = (PORTD & B11100000) | B00001000; // Рисуем разделитель между символами
  else
    if (col5d < 7) // Если не вышли за пределы индикатора, рисуем символ
    {
      int curD = indicator[col5d];
      if (curD >= 0)
      {
        int r = 3 - col5m + ((1 - curD & 1) << 2); // Для символов с четным кодом берем старший полубайт
                                                   // С нечетным - младший
        if ((symbols[curD >> 1][lev] >> r) & 1)
          PORTD = (PORTD & B11100000) | (7 - lev);
        else
          PORTD = (PORTD & B11100000) | B00001000;
      }
      else
        PORTD = (PORTD & B11100000) | B00001000; // Символы с отрицательным кодом не рисуем (если вдруг понадобится не рисовать)
    }     
}

bool btn10Ready = true;
bool btn11Ready = true;
void loop() {
  delay(10);
  if (digitalRead(10))
    btn10Ready = true;
  if (digitalRead(11))
    btn11Ready = true;    
  if (btn10Ready && !digitalRead(10))
  {
    // Останавливаем/запускаем секундомер при нажатии на первую кнопку
    isRuning = !isRuning; 
    btn10Ready = false;
  }
  if (btn11Ready && !digitalRead(11) && !isRuning)
  {
    // Сбрасываем показания, если счет остановлен, при нажатии на вторую
    clearIndicator();
    btn11Ready = false;
    secCnt = 0;
  }
}
